\documentclass[t]{beamer}
%\mode<presentation>

\setbeamertemplate{itemize items}[circle]
\setbeamertemplate{headline}{% 
  \hfill% 
  \usebeamercolor[fg]{page number in head/foot}% 
  \usebeamerfont{page number in head/foot}% 
  \insertpagenumber% 
  \kern1em\vskip-1em% 
}
\usepackage{pgfpages}
%\setbeameroption{show notes}
%\setbeameroption{show notes on second screen=right}
\usepackage{apalike}
\usepackage{graphicx} % Required for including images
\graphicspath{{figures/}} % Location of the graphics files
\usepackage{booktabs} % Top and bottom rules for table
\usepackage[font=small,labelfont=bf]{caption} % Required for specifying captions to tables and figures
\usepackage{wrapfig} % Allows wrapping text around tables and figures
\usepackage{lipsum,adjustbox}
\usepackage[absolute,overlay]{textpos}
\usepackage{url}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{color}
\usepackage{array}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{minibox}
\usepackage{tikz}
\usepackage{tikz-dependency}
\usepackage{algorithmic}
\usepackage{mathtools}
\usetikzlibrary{arrows.meta,graphs,graphs.standard,graphdrawing,quotes,shapes}
\usegdlibrary{layered,trees}
\tikzset{
  invisible/.style={opacity=0},
  visible on/.style={alt={#1{}{invisible}}},
  alt/.code args={<#1>#2#3}{%
    \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} % \pgfkeysalso doesn't change the path
  },
}
\captionsetup{labelformat=empty}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\makeatletter
\pgfdeclareshape{vector}{
	  \inheritsavedanchors[from={rectangle}]
	  \inheritbackgroundpath[from={rectangle}]
	  \inheritanchorborder[from={rectangle}]
	  \foreach \x in {center,north east,north west,north,south,south east,south west,east,west}{
	    \inheritanchor[from={rectangle}]{\x}
	  }

    \backgroundpath{
      \pgftransformshift{\pgfpoint{-16pt}{-4pt}}
		  \draw[rounded corners=2pt] (0,0) rectangle (32pt,8pt);
    }

    \beforebackgroundpath{
      \draw[step=8pt,help lines,-] (8pt,.1pt) grid (24pt,7.9pt);
    }
}
\makeatother

\AtBeginSection[]{
  \begin{frame}
  \vfill
  \centering
  \begin{beamercolorbox}[sep=8pt,center,shadow=true,rounded=true]{title}
    \usebeamerfont{title}\insertsectionhead\par%
  \end{beamercolorbox}
  \vfill
  \end{frame}
}

\title{Transition-Based Parsing}
\author{Daniel Hershcovich}
\date{NLP Course \\ December 24, 2017}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


%----------------------------------------------------------------------------------------

\section{Introduction}

\begin{frame}
  \frametitle{Dependency parsing}
  Given sentence $w=(w_1, \ldots, w_n)$,
  let $V_w=\{0, 1, \ldots, n \}$ \\
  (the root node has index 0).
  
  Derive dependency tree $T=(V_w,A)$ by finding the set of arcs
  $A \subset V_w \times \mathcal{L} \times V_w$,
  where $\mathcal{L}$ is the set of possible edge labels.
  
  \vfill

  Equivalently---for each $i$, find $w_i$'s head and dependency label.
  
  \pause
  
  \begin{center}
	  \begin{minipage}{4cm}
	    $w=(w_1, w_2, w_3)$ \hfill $\Rightarrow$
	  \end{minipage}
	  \begin{minipage}{5cm}
	    \begin{dependency}
	      \begin{deptext}[column sep=1.5em,ampersand replacement=\^,font=\rmfamily]
	        $w_1$ \^ $w_2$ \^ $w_3$ \\
	      \end{deptext}
	      \deproot{2}{root}
	      \depedge{2}{1}{nsubj}
	      \depedge{2}{3}{dobj}
	    \end{dependency}
	  \end{minipage}
  \end{center}
  \[
      V_w=\{0,1,2,3\}, \quad
      A=\{(0,\mathrm{root},2),(2,\mathrm{nsubj},1),(2,\mathrm{dobj},3)\}
  \]
  
  \pause

  In transition-based parsing,
  the problem is decomposed to finding a sequence of \textit{transitions}.
\end{frame}

\begin{frame}
  \frametitle{Example}
    \scalebox{.6}{\begin{varwidth}{1.8\linewidth}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& saw \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\end{dependency}
	\\
	\begin{tabular}{|l|}\hline
	\color{red} root \\ \hline
	\end{tabular}
	\hfill
	\begin{tabular}{|l|l|l|}
	\hline
	\color{blue} Alice & \color{blue} saw & \color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{shift}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& saw \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|}\hline
	\color{red} root & \color{red} Alice \\ \hline
	\end{tabular}
	\hfill
	\begin{tabular}{|l|l|}\hline
	\color{blue} saw & \color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{shift}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& saw \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|l|}\hline
	\color{red} root & \color{red} Alice & \color{red} saw \\ \hline
	\end{tabular}
	\hfill
	\begin{tabular}{|l|}\hline
	\color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{left}\\ \textsc{arc}\\{\footnotesize nsubj}\\$\rightarrow$\end{tabular}

    \vspace{5mm}
	
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& saw \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\depedge{2}{1}{nsubj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|}\hline
	\color{red} root & \color{red} saw \\ \hline
	\end{tabular}
	\hspace{11mm}
	\begin{tabular}{|l|}\hline
	\color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{shift}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& saw \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\depedge{2}{1}{nsubj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|l|} \hline
	\color{red} root & \color{red} saw & \color{red} Bob \\ \hline
	\end{tabular}
	\hspace{5.6mm}
	\begin{tabular}{|l|}\hline
	\quad \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{right}\\ \textsc{arc}\\{\footnotesize dobj}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& saw \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\depedge{2}{1}{nsubj}
	\depedge{2}{3}{dobj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|}\hline
	\color{red} root & \color{red} saw \\ \hline
	\end{tabular}
	\hspace{16mm}
	\begin{tabular}{|l|}\hline
	\quad \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{right}\\ \textsc{arc}\\{\footnotesize root}\\$\rightarrow$\end{tabular}
	
    \vspace{5mm}
	
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& saw \& Bob \\
	\end{deptext}
	\deproot{2}{root}
	\depedge{2}{1}{nsubj}
	\depedge{2}{3}{dobj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|}\hline
	\color{red} root \\ \hline
	\end{tabular}
	\hspace{27mm}
	\begin{tabular}{|l|}\hline
	\quad \\ \hline
	\end{tabular}
	}
    \end{varwidth}
	}
\end{frame}

\section{Transition systems}

\begin{frame}
  \frametitle{Configurations}
  Transitions operate on the parser \textit{configuration} (or \textit{state})
  \[
    c = (\Sigma, B, A)
  \]
  where
  \begin{itemize}
    \item $\Sigma \subseteq V_w$ is the stack of partially processed items.
    \item $B \subseteq V_w$ is the buffer of remaining input tokens.
    \item $A \subset V_w \times \mathcal{L} \times V_w$ is the set of arcs constructed so far.
  \end{itemize}
  
  \pause\vfill
  
  Common notation:
  \begin{equation*}
  \begin{split}
      \Sigma&=[\ldots,s_1,s_0]=\Sigma^\prime|s_1|s_0 \\
      B&=[b_0,b_1,\ldots]=b_0|b_1|B^\prime
  \end{split}
  \end{equation*}
\end{frame}

\begin{frame}
  \frametitle{Transition systems}  
  
  A \textit{transition system} is defined as
  \[
    S = (\mathcal{C}, \mathcal{T}, c_s, C_t)
  \]
  where
  \begin{itemize}
    \item $\mathcal{C}$ is the set of possible configurations.
    \item $\mathcal{T} \subset \mathcal{C}^\mathcal{C}$ is the set of \textit{transitions}.
    \item $c_s$ maps every sentence $w$ to an initial configuration $c_s(w)$.
    \item $C_t \subset \mathcal{C}$ is the set of terminal configurations.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Transition sequence}  
  A \textit{transition sequence} is $(c_0, \ldots, c_m) \subseteq \mathcal{C}$ s.t.
  \begin{itemize}
    \item $c_0 = c_s(w)$
    \item $c_m = (\Sigma_m, B_m, A_m) \in C_t$
    \item For each $i=1,\ldots,m$ there exists $t\in \mathcal{T}$ s.t. $c_{i+1}=t(c_i)$.
  \end{itemize}
  
  The output of the system is then $T=(V_w,A_m)$.
\end{frame}

\begin{frame}
  \frametitle{Arc-standard transition system \cite{nivre2004incrementality}}
  Transition set $\mathcal{T}$:

  \begin{tabular}{ll}
    $\textsc{shift}$ & move one item from the buffer to the stack: \\
    & $(\Sigma, \; i | B, \; A) \Rightarrow (\Sigma | i, \; B, \; A)$ \\
    \hline
    $\textsc{left-arc}_\ell$ & create arc $s_0 \to s_1$ with label $\ell \in \mathcal{L}$ and remove $s_1$: \\
    & $(\Sigma | i|j, \; B, \; A) \Rightarrow (\Sigma | j, \; B, \; A \cup \{(j,\ell,i)\})$ \\
    & Condition: $i\neq0$ \\
    \hline
    $\textsc{right-arc}_\ell$ & create arc $s_1 \to s_0$ with label $\ell \in \mathcal{L}$ and remove $s_0$: \\
    & $(\Sigma | i|j, \; B, \; A) \Rightarrow (\Sigma | i, \; B, \; A \cup \{(i,\ell,j)\})$  
  \end{tabular}
  
  \pause\vfill
  
  Typically $|\mathcal{L}| \approx 50$,
  so there are 101 different transitions.

  \pause\vfill

  Initial configuration:
  \[
    c_s(w_1, w_2, w_3, \ldots,) = ([0], [1, 2, 3, \ldots], \emptyset)
  \]

  Terminal configuration:
  \[
    c_t = ([0], [], A)
  \]
\end{frame}

\begin{frame}
  \frametitle{Properties of the arc-standard system
  \footnotetext[1]{\url{http://aclweb.org/anthology/J08-4003}}}
  \begin{description}
  \item[Soundness.] Every transition sequence outputs a projective tree.
  \item[Completeness.] Every projective tree is output by some sequence.
  \item[Complexity.] Input of length $n$ requires exactly $2n$ transitions.
  \item[Bottom-up.] Attaches a token's head only after all dependents.
  \end{description}
\end{frame}

\begin{frame}
  \frametitle{Another example for arc-standard transition sequence}
    \scalebox{.5}{\begin{varwidth}{2.2\linewidth}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\end{dependency}
	\\
	\begin{tabular}{|l|}\hline
	\color{red} root \\ \hline
	\end{tabular}
	\hfill
	\begin{tabular}{|l|l|l|l|}
	\hline
	\color{blue} Alice & \color{blue} looked & \color{blue} at & \color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{shift}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|}\hline
	\color{red} root & \color{red} Alice \\ \hline
	\end{tabular}
	\hfill
	\begin{tabular}{|l|l|l|}\hline
	\color{blue} looked & \color{blue} at & \color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{shift}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|l|}\hline
	\color{red} root & \color{red} Alice & \color{red} looked \\ \hline
	\end{tabular}
	\hfill
	\begin{tabular}{|l|l|}\hline
	\color{blue} at & \color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{left}\\ \textsc{arc}\\{\footnotesize nsubj}\\$\rightarrow$\end{tabular}

    \vspace{5mm}
	
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\depedge{2}{1}{nsubj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|}\hline
	\color{red} root & \color{red} looked \\ \hline
	\end{tabular}
	\hspace{11mm}
	\begin{tabular}{|l|l|}\hline
	\color{blue} at & \color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{shift}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\depedge{2}{1}{nsubj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|l|} \hline
	\color{red} root & \color{red} looked & \color{red} at \\ \hline
	\end{tabular}
	\hspace{11mm}
	\begin{tabular}{|l|}\hline
	\color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{shift}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\depedge{2}{1}{nsubj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|l|l|}\hline
	\color{red} root & \color{red} looked & \color{red} at & \color{red} Bob \\ \hline
	\end{tabular}
	\hspace{6mm}
	\begin{tabular}{|l|}\hline
	\quad \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{right}\\ \textsc{arc}\\{\footnotesize pobj}\\$\rightarrow$\end{tabular}
	
    \vspace{5mm}
	
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\depedge{2}{1}{nsubj}
	\depedge{3}{4}{pobj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|l|} \hline
	\color{red} root & \color{red} looked & \color{red} at \\ \hline
	\end{tabular}
	\hspace{17mm}
	\begin{tabular}{|l|}\hline
	\quad \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{right}\\ \textsc{arc}\\{\footnotesize prep}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\depedge{2}{1}{nsubj}
	\depedge{2}{3}{prep}
	\depedge{3}{4}{pobj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|l|}\hline
	\color{red} root & \color{red} looked \\ \hline
	\end{tabular}
	\hspace{25mm}
	\begin{tabular}{|l|}\hline
	\quad \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{right}\\ \textsc{arc}\\{\footnotesize root}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot{2}{root}
	\depedge{2}{1}{nsubj}
	\depedge{2}{3}{prep}
	\depedge{3}{4}{pobj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|}\hline
	\color{red} root \\ \hline
	\end{tabular}
	\hspace{40mm}
	\begin{tabular}{|l|}\hline
	\quad \\ \hline
	\end{tabular}
	}
    \end{varwidth}
	}
	
	\pause\vfill
	Might be a good idea to attach $\textrm{looked} \to \textrm{at}$ as soon as possible?
\end{frame}


\begin{frame}
  \frametitle{Arc-eager transition system \cite{nivre2004incrementality}}
  \begin{tabular}{ll}
    $\textsc{shift}$ & move one item from the buffer to the stack: \\
    (same) & $(\Sigma, \; i | B, \; A) \Rightarrow (\Sigma | i, \; B, \; A)$ \\
    \hline
    $\textsc{left-arc}_\ell$ & create arc $b_0 \to s_0$ with label $\ell \in \mathcal{L}$ and remove $s_0$: \\
    & $(\Sigma | i, \; j | B, \; A) \Rightarrow (\Sigma, \; j | B, \; A \cup \{(j,\ell,i)\})$ \\
    & Condition: $i\neq0$ and $i$ has no head \\
    \hline
    $\textsc{right-arc}_\ell$ & create arc $s_0 \to b_0$ with label $\ell \in \mathcal{L}$ and shift $b_0$: \\
    & $(\Sigma | i, \; j | B, \; A) \Rightarrow (\Sigma | i|j, \; B, \; A \cup \{(i,\ell,j)\})$   \\
    \hline
    $\textsc{reduce}$ & remove $s_0$: \\
    & $(\Sigma | i, \; B, \; A) \Rightarrow (\Sigma, \; B, \; A)$ \\
    & Condition: $i$ has a head
  \end{tabular}
  
  \pause\vfill

  Initial configuration (same as arc-standard):
  \[
    c_s(w_1, w_2, w_3, \ldots,) = ([0], [1, 2, 3, \ldots], \emptyset)
  \]

  Terminal configuration ($\Sigma$ does not have to be $[0]$):
  \[
    c_t = (\Sigma, [], A)
  \]
\end{frame}

\begin{frame}
  \frametitle{Properties of the arc-eager system}
  Soundness and completeness are the same as arc-standard.
  
  Complexity: \textbf{at most} $2n$.
  
  Builds parts of the tree top-down instead of bottom-up.
\end{frame}

\begin{frame}
  \frametitle{Example arc-eager transition sequence}
    \scalebox{.5}{\begin{varwidth}{2.2\linewidth}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\end{dependency}
	\\
	\begin{tabular}{|l|}\hline
	\color{red} root \\ \hline
	\end{tabular}
	\hfill
	\begin{tabular}{|l|l|l|l|}
	\hline
	\color{blue} Alice & \color{blue} looked & \color{blue} at & \color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{shift}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|}\hline
	\color{red} root & \color{red} Alice \\ \hline
	\end{tabular}
	\hfill
	\begin{tabular}{|l|l|l|}\hline
	\color{blue} looked & \color{blue} at & \color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{left}\\ \textsc{arc}\\{\footnotesize nsubj}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot[color=white]{2}{root}
	\depedge{2}{1}{nsubj}
	\end{dependency}
	\\
	\begin{tabular}{|l|}\hline
	\color{red} root \\ \hline
	\end{tabular}
	\hfill
	\begin{tabular}{|l|l|l|}\hline
	\color{blue} looked & \color{blue} at & \color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{right}\\ \textsc{arc}\\{\footnotesize root}\\$\rightarrow$\end{tabular}

    \vspace{5mm}
	
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot{2}{root}
	\depedge{2}{1}{nsubj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|}\hline
	\color{red} root & \color{red} looked \\ \hline
	\end{tabular}
	\hspace{11mm}
	\begin{tabular}{|l|l|}\hline
	\color{blue} at & \color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{right}\\ \textsc{arc}\\{\footnotesize prep}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot{2}{root}
	\depedge{2}{1}{nsubj}
	\depedge{2}{3}{prep}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|l|} \hline
	\color{red} root & \color{red} looked & \color{red} at \\ \hline
	\end{tabular}
	\hspace{11mm}
	\begin{tabular}{|l|}\hline
	\color{blue} Bob \\ \hline
	\end{tabular}
	}
	\begin{tabular}{c}\textsc{right}\\ \textsc{arc}\\{\footnotesize pobj}\\$\rightarrow$\end{tabular}
	\minibox[frame]{
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& looked \& at \& Bob \\
	\end{deptext}
	\deproot{2}{root}
	\depedge{2}{1}{nsubj}
	\depedge{2}{3}{prep}
	\depedge{3}{4}{pobj}
	\end{dependency}
	\\
	\begin{tabular}{|l|l|l|l|}\hline
	\color{red} root & \color{red} looked & \color{red} at & \color{red} Bob \\ \hline
	\end{tabular}
	\hspace{6mm}
	\begin{tabular}{|l|}\hline
	\quad \\ \hline
	\end{tabular}
	}
    \end{varwidth}
	}
\end{frame}

\section{Greedy transition-based parsing}

\begin{frame}
  \frametitle{Transition-based (shift-reduce) parsing}
    To actually parse text, we need to decide which transitions to take.
    \[
        P(t_1,\ldots,t_m|w)=\prod_{i=1}^mP(t_i|t_1,\ldots,t_{i-1},w)=\prod_{i=1}^mP(t_i|c_{i-1})
    \]
    so inference is
    \[
    \argmax_{t_1,\ldots,t_m \in \mathcal{T}} \prod_{i=1}^mP(t_i|c_{i-1})
    \]

    But training examples are trees, not sequences.
    
    To learn this score, we need an \textit{oracle} to tell the correct sequence:
    \[
    o(T)=(t_1,\ldots,t_m)
    \]
    
    \pause\vfill
    
    \begin{minipage}{.5\textwidth}
	\begin{dependency}
	\begin{deptext}[column sep=.7cm]
	Alice \& saw \& Bob \\
	\end{deptext}
	\deproot{2}{root}
	\depedge{2}{1}{nsubj}
	\depedge{2}{3}{dobj}
	\end{dependency}
	\end{minipage}
    \begin{minipage}{.1\textwidth}
	$\Rightarrow$
	\end{minipage}
    \begin{minipage}{.2\textwidth}
    $\textsc{shift}$,
	$\textsc{shift}$,
	$\textsc{left-arc}_\mathrm{nsubj}$,
	$\textsc{shift}$,
	$\textsc{right-arc}_\mathrm{dobj}$,
	$\textsc{right-arc}_\mathrm{root}$
	\end{minipage}
\end{frame}

\begin{frame}
    \frametitle{Oracle for arc-standard}
    \begin{algorithmic}[0]
    \WHILE{$B\neq[]$ and $\Sigma\neq[0]$}
        \IF{$s_0\xrightarrow{\ell} s_1$ and $s_1$ has all its children and $s_1\neq0$}
            \RETURN $\textsc{left-arc}_\ell$
        \ELSIF{$s_1\xrightarrow{\ell} s_0$ and $s_0$ has all its children and $s_0\neq0$}
            \RETURN $\textsc{right-arc}_\ell$
        \ELSE
            \RETURN $\textsc{shift}$
        \ENDIF
    \ENDWHILE
    \end{algorithmic}
\end{frame}

\begin{frame}
    \frametitle{Oracle for arc-eager}
    \begin{algorithmic}[0]
    \WHILE{$B\neq[]$}
        \IF{$b_0\xrightarrow{\ell} s_0$}
            \RETURN $\textsc{left-arc}_\ell$
        \ELSIF{$s_0\xrightarrow{\ell} b_0$}
            \RETURN $\textsc{right-arc}_\ell$
        \ELSIF{$s_0$ has all its children and a head}
            \RETURN $\textsc{reduce}$
        \ELSE
            \RETURN $\textsc{shift}$
        \ENDIF
    \ENDWHILE
    \end{algorithmic}
\end{frame}

\begin{frame}
    \frametitle{Greedy transition-based parsing}
    In \textit{greedy parsing}, instead of    
    \[
    (t_1,\ldots,t_m)=\argmax_{t^\prime_1,\ldots,t^\prime_m \in \mathcal{T}} \prod_{i=1}^mP(t^\prime_i|c_{i-1})
    \]
    we select each transition separately and sequentially:
    \[
    t_i = \argmax_{t^\prime_i \in \mathcal{T}} P(t^\prime_i|c_{i-1}) \quad i=1,\ldots,m
    \]
    
    \pause\vfill
    
    To estimate this probability, we estimate it by a score $s(t, c)$.
    The whole parsing process is then just:
    \begin{algorithmic}[0]
    \STATE{$c\leftarrow c_s(w)$}
    \WHILE{$c\not\in C_t$}
        \STATE{$c\leftarrow\Big(\argmax_{t\in\mathcal{T}}s(t,c)\Big)(c)$}
    \ENDWHILE
    \end{algorithmic}
\end{frame}

\begin{frame}
    \frametitle{Transition classifiers}
    Learn the score giving maximum probability to oracle transitions:
    \[
    \argmax_{s\in\mathcal{S}}\sum_{i=1}^ms(t^*_i,c^*_{i-1})
    \]
    where $t^*_1,\ldots,t^*_m$ (and $c^*_1,\ldots,c^*_m$) are determined by the oracle.
    
    \pause\vfill
    
    Possible hypothesis classes $\mathcal{S}$:
    \begin{enumerate}
    \item Linear
    \item SVM
    \item Feedforward neural networks
    \item Recurrent neural networks
    \end{enumerate}
\end{frame}

\begin{frame}
    \frametitle{Linear transition classifier}
    Given features $\mathbf{f}=(f_1, \ldots, f_K) : \mathcal{C}\to\mathbb{R}^K$, learn weights $W_{|\mathcal{T}|\times K}$:
    \[
    s(t,c)=\big[W\cdot\mathbf{f}(c)\big]_t
    \]
    Typically trained by the perceptron algorithm, with binary features:
	words, POS and existing arc labels of stack and buffer nodes, and
	their heads and dependents.
    
    \pause\vfill
    
    Feature templates:
    
    \begin{minipage}{.5\textwidth}
	\begin{adjustbox}{margin=3pt,frame,scale=.6}
	\begin{tabular}{l}
	\textbf{unigrams} \\
	$s_0ta, s_0wa, s_1ta, s_1wa, s_2ta, s_2wa, s_3ta, s_3wa,$ \\
	$b_0wt, b_1wt, b_2wt, b_3wt,s_0lwa, s_0rwa, s_1lwa, s_1rwa,$ \\
	$s_0hw$ \\
	\textbf{bigrams} \\
	$s_0ws_1w, s_0ws_1a, s_0as_1w, s_0as_1a, s_0wb_0w, s_0wb_0t,$ \\
	$s_0ab_0w, s_0ab_0t, s_1wb_0w, s_1wb_0t, s_1ab_0w, s_1ab_0t,$ \\
	$b_0wb_1w, b_0wb_1t, b_0tb_1w, b_0tb_1t$ \\
	\textbf{trigrams} \\
	$s_0as_1as_2w, s_0as_1as_2a, s_0as_1ab_0w, s_0as_1ab_0t,$ \\
	$s_0as_1wb_0w, s_0as_1wb_0t, s_0ws_1as_2a, s_0ws_1ab_0t$
	\end{tabular}
	\end{adjustbox}
	\end{minipage}
	\begin{minipage}{.45\textwidth}\scriptsize
	  $s_i$, $b_i$: $i$th stack, buffer items.\\
	  $w$, $t$: word form, POS tag. \\
	  $a$: arc label to the node.\\
	  $l$, $r$: left, right dependents. \\
	  $h$: head.
	\end{minipage}
\end{frame}




\section{More transition systems}

\begin{frame}
  \frametitle{Non-projective parsing}
  \begin{center}
    \begin{dependency}
      \begin{deptext}[column sep=1.5em,ampersand replacement=\^,font=\rmfamily]
        That \^ 's \^ what \^ they \^ 're \^ after \\
      \end{deptext}
      \depedge{2}{1}{nsubj}
      \deproot{2}{root}
      \depedge{6}{3}{}
      \depedge{5}{4}{nsubj}
      \depedge[edge unit distance=.75em]{2}{5}{}
      \depedge{5}{6}{}
    \end{dependency}
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Swap-standard transition system}
  Like arc-standard, but adding a \textsc{swap} transition:

  \begin{tabular}{ll}
    $\textsc{shift}$ & move one item from the buffer to the stack. \\
    $\textsc{left-arc}$ & create arc $(s_0, s_1)$ and remove $s_1$. \\
    $\textsc{right-arc}$ & create arc $(s_1, s_0)$ and remove $s_0$. \\
    $\textsc{swap}$ & switch $s_0$ and $s_1$.
  \end{tabular}
\end{frame}

\begin{frame}[allowframebreaks]
\frametitle{References}
\bibliographystyle{apalike}
\tiny\bibliography{references}
\end{frame}

%\begin{frame}
%\frametitle{TUPA --- Transition-based UCCA Parser}
%The \textbf{first parser} to support the combination of three properties:
%\begin{enumerate}
%\item<1-> {\color{blue} Non-terminal nodes} --- entities and events over the text
%\item<2-> {\color{orange} Reentrancy} --- allow argument sharing
%\item<3-> {\color{red} Discontinuity} --- conceptual units are split
%\end{enumerate}
%\onslide<3->{--- needed for many semantic schemes (e.g. AMR, UCCA).}
%\begin{center}
% \newcommand*\reecol{}
% \newcommand*\reewid{}
% \only<2->{\renewcommand*\reecol{orange}}
% \only<2->{\renewcommand*\reewid{very thick}}
% \newcommand*\discol{}
% \newcommand*\diswid{}
% \only<3->{\renewcommand*\discol{red}}
% \only<3->{\renewcommand*\diswid{very thick}}
%  \begin{tikzpicture}[level distance=16mm, sibling distance=2cm, ->]
%  \tikzstyle{word} = [font=\rmfamily,color=black]
%    \node (ROOT) [fill=blue, circle] {}
%      child {node (You) [word] {You} edge from parent}
%      child {node [word] {want} edge from parent}
%      child {node (totakealongbath) [fill=blue, circle] {}
%      {
%        child {node [word] {to} edge from parent}
%        child {node (takeabath) [fill=blue, circle] {}
%        {
%          child {node [word] {take} edge from parent}
%          child {node [word] {a} edge from parent}
%          child {node [word] (long) {long} edge from parent[draw=none]}
%          child {node [word] {bath} edge from parent}
%        } edge from parent}
%      } edge from parent}
%      ;
%    \draw[bend left,dashed,->,\reecol,\reewid] (takeabath) to (You);
%    \draw[bend left,->,\discol,\diswid] (totakealongbath) to (long);
%  \end{tikzpicture}
%\end{center}
%\end{frame}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Introduction}
%
%\begin{frame}
%\frametitle{Linguistic Structure Annotation Schemes}
%\begin{itemize}
%	\setlength\itemsep{1em}
%	\item Syntactic dependencies
%	\item Semantic dependencies \cite{oepen2016towards}
%  	\only<2>{
%  	\item Semantic role labeling (PropBank, FrameNet)
%	\item AMR \cite{banarescu2013abstract}
%	\item UCCA \cite{abend2013universal}
%	\item Other semantic representation schemes\footnote{See recent survey \cite{abend2017state}}
%	}
%\end{itemize}
%\vfill
%\only<1>{
%	\begin{flushleft}
%	Syntactic (UD)\\
%	\end{flushleft}
%	\vspace{-1cm}
%	\begin{adjustbox}{margin=1cm 5mm 1cm 5mm,frame,center}
%	\begin{dependency}
%		\begin{deptext}[column sep=1.5em,ampersand replacement=\^,font=\rmfamily]
%		You \^ want \^ to \^ take \^ a \^ long \^ bath \\
%		\end{deptext}
%		\deproot{2}{root}
%		\depedge{2}{1}{nsubj}
%		\depedge[edge start x offset=-4pt]{2}{4}{xcomp}
%		\depedge{2}{3}{mark}
%		\depedge{4}{7}{dobj}
%		\depedge{7}{5}{det}
%		\depedge{7}{6}{amod}
%		\deproot[edge below,edge style={red},edge unit distance=1em]{2}{top}
%		\depedge[edge below,draw=red]{2}{4}{ARG2}
%		\depedge[edge below,draw=red]{2}{1}{ARG1}
%		\depedge[edge below,draw=red,edge unit distance=1.6em,edge start x offset=6pt]{4}{1}{ARG1}
%		\depedge[edge below,draw=red]{4}{7}{ARG2}
%		\depedge[edge below,draw=red]{5}{7}{BV}
%		\depedge[edge below,draw=red]{6}{7}{ARG1}
%	\end{dependency}
%	\end{adjustbox}\\
%	\vspace{-1cm}
%	\begin{flushright}
%	\color{red}Semantic (DM)
%	\end{flushright}
%	\captionof{figure}{Bilexical dependencies.}
%}
%\only<2>{
%Semantic representation schemes attempt to
%abstract away from syntactic detail that does not affect meaning:
%\begin{center}
%	\fbox{\textrm{\ldots bathed}} = \fbox{\textrm{\ldots took a bath}}
%\end{center}
%}
%\vfill
%\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%
%\section{The UCCA Semantic Representation Scheme}
%
%\begin{frame}
%\frametitle{Universal Conceptual Cognitive Annotation (UCCA)}
%Cross-linguistically applicable \cite{abend2013universal}.
%Stable in translation \cite{sulem2015conceptual}.
%
%\vfill
%English\\
%\vspace{-1cm}
%\begin{adjustbox}{center}
%  \includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{crosslinguistic.png}
%\end{adjustbox}
%\\
%\vspace{-1cm}
%Hebrew
%\end{frame}
%
%\begin{frame}
%\frametitle{Universal Conceptual Cognitive Annotation (UCCA)}
%Rapid and intuitive annotation interface \cite{abend2017uccaapp}.
%Usable by non-experts.
%\hfill\url{ucca-demo.cs.huji.ac.il}
%\vfill
%
%Facilitates semantics-based human evaluation of machine translation \cite{birch2016hume}.
%\hfill\url{ucca.cs.huji.ac.il/mteval}
%\vfill
%\begin{adjustbox}{center}
%  \includegraphics[width=\pagewidth,height=\textheight,keepaspectratio]{uccaapp.png}
%\end{adjustbox}
%\end{frame}
%
%\begin{frame}
%\frametitle{Graph Structure}
%UCCA generates a directed acyclic graph (DAG). \\
%Text tokens are terminals, complex units are {\color{blue} non-terminal nodes}. \\
%\textit{Remote edges} enable {\color{orange} reentrancy} for argument sharing. \\
%Phrases may be {\color{red} discontinuous} (e.g., multi-word expressions).
%
%\hspace*{1cm}
%  \begin{tikzpicture}[level distance=16mm, sibling distance=2cm, ->]
%  \tikzstyle{word} = [font=\rmfamily,color=black]
%    \node (ROOT) [fill=blue, circle] {}
%      child {node (You) [word] {You} edge from parent node[left] {\scriptsize $A$}}
%      child {node [word] {want} edge from parent node[left] {\scriptsize $P$}}
%      child {node (totakealongbath) [fill=blue, circle] {}
%      {
%        child {node [word] {to} edge from parent node[left] {\scriptsize $F$}}
%        child {node (takeabath) [fill=blue, circle] {}
%        {
%          child {node [word] {take} edge from parent node[right] {\scriptsize $C$}}
%          child {node [word] {a} edge from parent node[right] {\scriptsize $F$}}
%          child {node [word] (long) {long} edge from parent[draw=none]}
%          child {node [word] {bath} edge from parent node[right] {\scriptsize $C$}}
%        } edge from parent node[right] {\scriptsize $P$} }
%      } edge from parent node[left] {\scriptsize $A$} }
%      ;
%    \draw[bend left,dashed,->,orange,very thick] (takeabath) to node [auto] {\scriptsize $A$} (You);
%    \draw[bend left,->,red,very thick] (totakealongbath) to node [auto] {\scriptsize $D$} (long);
%    \node at (6,-0.4) {\Large ----- primary edge};
%    \node at (6,-1.4) {\Large - - - remote edge};
%\end{tikzpicture}
%\begin{center}
%  You want to take a long bath
%\end{center}
%
%\vspace{-26mm}
%\begin{adjustbox}{margin=1pt,frame,scale=.9}
%  \begin{tabular}{c>{\small\it}l}
%	  $P$ & process \\
%	  $A$ & participant \\
%	  $C$ & center \\
%	  $D$ & adverbial \\
%	  $F$ & function
%  \end{tabular}
%\end{adjustbox}
%\end{frame}
%
%
%
%\section{Transition-based UCCA Parsing}
%
%\begin{frame}
%\frametitle{Transition-Based Parsing}
%First used for dependency parsing \cite{nivre2004incrementality}.
%
%Parse text $w_1 \ldots w_n$ to graph $G$ incrementally by applying transitions to the parser state:
%stack, buffer and constructed graph.
%
%\pause
%\vfill
%Initial state:
%\begin{tikzpicture}[every node/.append style={font=\rmfamily}, circle]
%	\draw[xstep=1cm,ystep=5mm,color=gray] (-0.01,0) grid (1,.5);
%	\node[anchor=west,style={font=\sffamily}] at (-0.1,1.00)     {stack};
%	\node[fill=black] at (0.5,0.25) {};
%	\draw[xstep=1cm,ystep=5mm,color=gray] (3,0) grid (10,.5);
%	\node[anchor=west,style={font=\sffamily}] at (8.9,1.00) {buffer};
%	\node[anchor=west] at (3,0.25) {\small You};
%	\node[anchor=west] at (4,0.25) {\small want};
%	\node[anchor=west] at (5,0.25) {\small to};
%	\node[anchor=west] at (6,0.25) {\small take};
%	\node[anchor=west] at (7,0.25) {\small a};
%	\node[anchor=west] at (8,0.25) {\small long};
%	\node[anchor=west] at (9,0.25) {\small bath};
%\end{tikzpicture}
%
%\vfill
%\pause
%TUPA transitions:
%
%\{\textsc{Shift, Reduce, Node$_\ell$, Left-Edge$_\ell$, Right-Edge$_\ell$,}\\
%\hspace{5mm}\textsc{Left-Remote$_\ell$, Right-Remote$_\ell$, Swap, Finish}\}
%
%\vfill
%Support {\color{blue}non-terminal nodes}, {\color{orange}reentrancy} and {\color{red}discontinuity}.
%\end{frame}
%
%\begin{frame}
%\frametitle{Example}
%\begin{minipage}[t][8mm][t]{\textwidth}
%	$\Rightarrow$\textsc{
%		\only<1>{Shift}\only<2>{Right-Edge$_A$}\only<3>{Shift}\only<4>{Swap}\only<5>{Right-Edge$_P$}\only<6>{Reduce}\only<7>{Shift}\only<8>{Shift}\only<9>{Node$_F$}\only<10>{Reduce}\only<11>{Shift}\only<12>{Shift}\only<13>{Node$_C$}\only<14>{Reduce}\only<15>{Shift}\only<16>{Right-Edge$_P$}\only<17>{Shift}\only<18>{Right-Edge$_F$}\only<19>{Reduce}\only<20>{Shift}\only<21>{Swap}\only<22>{Right-Edge$_D$}\only<23>{Reduce}\only<24>{Swap}\only<25>{Right-Edge$_A$}\only<26>{Reduce}\only<27>{Reduce}\only<28>{Shift}\only<29>{Shift}\only<30>{Left-Remote$_A$}\only<31>{Shift}\only<32>{Right-Edge$_C$}\only<33>{Finish}
%	}
%\end{minipage}
%
%\vfill
%
%\begin{tikzpicture}[every node/.append style={font=\rmfamily}]
%	\only<28>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (-0.01,0) grid (1,.5);
%	\only<1,7,29>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (.99,0) grid (2,.5);
%	\only<2,5,25>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (-0.01,0) grid (2,.5);
%	\only<3,8,11,31>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (1.99,0) grid (3,.5);
%	\only<12,15>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (2.99,0) grid (4,.5);
%	\only<17,20>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (3.99,0) grid (5,.5);
%	\only<16>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (1.99,0) grid (4,.5);
%	\only<18>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (2.99,0) grid (5,.5);
%	\only<4>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (4,0) grid (5,.5);
%	\only<9>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (5,0) grid (6,.5);
%	\only<13>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (6,0) grid (7,.5);
%	\only<21>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (8,0) grid (9,.5);
%	\only<24>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (7,0) grid (8,.5);
%	\only<22>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (1.99,0) grid (4,.5);
%	\only<30>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (-0.01,0) grid (2,.5);
%	\only<32>\draw[xstep=1cm,ystep=5mm,color=red,line width=1pt] (.99,0) grid (3,.5);
%	\only<27>\draw[xstep=1mm,ystep=5mm,color=gray] (-0.01,0) grid (0.1,.5);
%	\only<6,26,28>\draw[xstep=1cm,ystep=5mm,color=gray] (-0.01,0) grid (1,.5);
%	\only<-2,4-5,7,10,24-25,29-30>\draw[xstep=1cm,ystep=5mm,color=gray] (-0.01,0) grid (2,.5);
%	\only<3,8-9,11,14,23,31->\draw[xstep=1cm,ystep=5mm,color=gray] (-0.01,0) grid (3,.5);
%	\only<12-13,15-16,19,21-22>\draw[xstep=1cm,ystep=5mm,color=gray] (-0.01,0) grid (4,.5);
%	\only<17-18,20>\draw[xstep=1cm,ystep=5mm,color=gray] (-0.01,0) grid (5,.5);
%	\node[anchor=west,style={font=\sffamily}] at (-0.1,1.00){stack};
%	\only<-26>\node[fill=black, circle] at (0.5,0.25) {};
%	\only<24-25> \node[fill=blue, circle] at (1.5,0.25) {};
%	\only<11-23> \node[fill=blue, circle] at (2.5,0.25) {};
%	\only<29-> \node[fill=red, circle] at (1.5,0.25) {};
%	\only<15-20> \node[fill=red, circle] at (3.5,0.25) {};
%	\only<28-> \node[anchor=west] at (0,0.25) {\small You};
%	\only<1-3,7-23> \node[anchor=west] at (1,0.25) {\small You};
%	\only<4-5> \node[anchor=west] at (1,0.25) {\small want};
%	\only<3>   \node[anchor=west] at (2,0.25) {\small want};
%	\only<8-9>  \node[anchor=west] at (2,0.25) {\small to};
%	\only<12-13> \node[anchor=west] at (3,0.25) {\small take};
%	\only<17-18> \node[anchor=west] at (4,0.25) {\small a};
%	\only<20> \node[anchor=west] at (4,0.25) {\small long};
%	\only<21-22> \node[anchor=west] at (3,0.25) {\small long};
%	\only<31-> \node[anchor=west] at (2,0.25) {\small bath};
%	\only<-2,4-5>\draw[xstep=1cm,ystep=5mm,color=gray] (4,0) grid (10,.5);
%	\only<3,5-7,9-10>\draw[xstep=1cm,ystep=5mm,color=gray] (5,0) grid (10,.5);
%	\only<8,11,13-14>\draw[xstep=1cm,ystep=5mm,color=gray] (6,0) grid (10,.5);
%	\only<12,15-16,24-27>\draw[xstep=1cm,ystep=5mm,color=gray] (7,0) grid (10,.5);
%	\only<17-19,21-23,28>\draw[xstep=1cm,ystep=5mm,color=gray] (8,0) grid (10,.5);
%	\only<20,29-30>\draw[xstep=1cm,ystep=5mm,color=gray] (9,0) grid (10,.5);
%	\only<31->\draw[xstep=1mm,ystep=5mm,color=gray] (9.89,0) grid (10,.5);
%	\node[anchor=west,style={font=\sffamily}] at (8.9,1) {buffer};
%	\only<9-10> \node[fill=blue, circle] at (5.5,0.25) {};
%	\only<13-14> \node[fill=red, circle] at (6.5,0.25) {};
%	\only<21-28> \node[fill=red, circle] at (8.5,0.25) {};
%	\only<4-5> \node[anchor=west] at (4,0.25) {\small You};
%	\only<24-27> \node[anchor=west] at (7,0.25) {\small You};
%	\only<-2>  \node[anchor=west] at (4,0.25) {\small want};
%	\only<-7> \node[anchor=west] at (5,0.25) {\small to};
%	\only<-11> \node[anchor=west] at (6,0.25) {\small take};
%	\only<-16> \node[anchor=west] at (7,0.25) {\small a};
%	\only<-19> \node[anchor=west] at (8,0.25) {\small long};
%	\only<-30> \node[anchor=west] at (9,0.25) {\small bath};
%\end{tikzpicture}
%\vfill
%\fbox{
%\begin{tikzpicture}[level distance=15mm, sibling distance=2cm, ->,
%    every node/.append style={font=\rmfamily}]
%	\node[anchor=west,style={font=\sffamily}] at (0,0) {graph};
%    \node(ROOT)[fill=black, circle, visible on=<1->] at (3,0) {}
%      child [visible on=<2->] {node (You) {You} edge from parent node [left] {\scriptsize $A$}}
%      child [visible on=<5->] {node (want) {want} edge from parent node [left] {\scriptsize $P$}}
%      child [visible on=<9->] {node (totakealongbath) [fill=blue, circle] {}
%      {
%        child [visible on=<9->] {node (to) {to} edge from parent node [left] {\scriptsize $F$}}
%        child [visible on=<13->] {node (takeabath) [fill=red, circle] {}
%        {
%          child [visible on=<13->] {node (take) {take} edge from parent node [right] {\scriptsize $C$}}
%          child [visible on=<18->] {node (a) {a} edge from parent node [right] {\scriptsize $F$}}
%          child [visible on=<22->] {node (long) {long} edge from parent [draw=none]}
%          child [visible on=<32->] {node (bath) {bath} edge from parent node [right] {\scriptsize $C$}}
%        } edge from parent [draw=none]}
%      } edge from parent [draw=none]}
%      ;
%    \draw[visible on=<16->] (totakealongbath) to node [left] {\scriptsize $P$} (takeabath);
%    \draw[visible on=<25->] (ROOT) to node [left] {\scriptsize $A$} (totakealongbath);
%    \draw[bend left,dashed, visible on=<30->] (takeabath) to node [auto] {\scriptsize $A$} (You);
%    \draw[bend left, visible on=<22->] (totakealongbath) to node [auto] {\scriptsize $D$} (long);
%    \draw[visible on=<2>,red] (ROOT) to node {} (You);
%    \draw[visible on=<5>,red] (ROOT) to node {} (want);
%    \draw[visible on=<16>,red] (totakealongbath) to node {} (takeabath);
%    \draw[visible on=<18>,red] (takeabath) to node {} (a);
%    \draw[bend left, visible on=<22>,red] (totakealongbath) to node {} (long);
%    \draw[visible on=<25>,red] (ROOT) to node {} (totakealongbath);
%    \draw[bend left,dashed, visible on=<30>,red] (takeabath) to node {} (You);
%    \draw[visible on=<32>,red] (takeabath) to node {} (bath);
%\end{tikzpicture}}
%\end{frame}
%
%\begin{frame}
%\frametitle{Training}
%An \textit{oracle} provides the transition sequence given the correct graph:
%
%\vfill
%\centering
%\scalebox{.8}{
%\begin{tikzpicture}[level distance=15mm, sibling distance=2cm, ->,
%    every node/.append style={font=\rmfamily}]
%    \node(ROOT)[fill=black, circle] at (3,0) {}
%      child {node (You) {You} edge from parent node [left] {\scriptsize $A$}}
%      child {node (want) {want} edge from parent node [left] {\scriptsize $P$}}
%      child {node (totakealongbath) [fill=blue, circle] {} 
%      { 
%        child {node (to) {to} edge from parent node [left] {\scriptsize $F$}}
%        child {node (takeabath) [fill=red, circle] {}
%        {
%          child {node (take) {take} edge from parent node [right] {\scriptsize $C$}}      
%          child {node (a) {a} edge from parent node [right] {\scriptsize $F$}} 
%          child {node (long) {long} edge from parent [draw=none]}
%          child {node (bath) {bath} edge from parent node [right] {\scriptsize $C$}}  
%        } edge from parent [draw=none]}
%      } edge from parent [draw=none]}
%      ;
%    \draw(totakealongbath) to node [left] {\scriptsize $P$} (takeabath); 
%    \draw(ROOT) to node [left] {\scriptsize $A$} (totakealongbath);
%    \draw[bend left,dashed] (takeabath) to node [auto] {\scriptsize $A$} (You);
%    \draw[bend left] (totakealongbath) to node [auto] {\scriptsize $D$} (long);
%\end{tikzpicture}}
%\[\Downarrow\]
%\begin{flushleft}
%\footnotesize
%\textsc{Shift}, \textsc{Right-Edge$_A$}, \textsc{Shift}, \textsc{Swap}, \textsc{Right-Edge$_P$}, \textsc{Reduce}, \textsc{Shift}, \textsc{Shift}, \textsc{Node$_F$}, \textsc{Reduce}, \textsc{Shift}, \textsc{Shift}, \textsc{Node$_C$}, \textsc{Reduce}, \textsc{Shift}, \textsc{Right-Edge$_P$}, \textsc{Shift}, \textsc{Right-Edge$_F$}, \textsc{Reduce}, \textsc{Shift}, \textsc{Swap}, \textsc{Right-Edge$_D$}, \textsc{Reduce}, \textsc{Swap}, \textsc{Right-Edge$_A$}, \textsc{Reduce}, \textsc{Reduce}, \textsc{Shift}, \textsc{Shift}, \textsc{Left-Remote$_A$}, \textsc{Shift}, \textsc{Right-Edge$_C$}, \textsc{Finish}
%\end{flushleft}
%\end{frame}
%
%\begin{frame}
%\only<-5>{
%\frametitle{TUPA Model}
%Learn to greedily predict transition based on current state.
%
%Experimenting with three classifiers:
%\vspace{5mm}
%
%	\begin{tabular}{ll}
%	\textbf{Sparse} & Perceptron with sparse features \cite{ZhangTDP11}. \\
%	\textbf{MLP} & Embeddings + feedforward NN \cite{chen2014fast}. \\
%	\textbf{BiLSTM} & Embeddings + \only<2->{\textbf}{deep bidirectional LSTM} + MLP \\&
%	\cite{kiperwasser2016simple}.
%	\onslide<2>{\\ \\& Effective ``lookahead'' encoded in the representation.}
%	\end{tabular}
%}
%\only<2-5>{\vspace{-53mm}}
%
%\only<1>{
%\vfill
%
%Features:
%words, POS, syntactic dependencies, existing edge labels \\
%from the stack and buffer + parents, children, grandchildren;
%ordinal features (height, number of parents and children)
%
%\vspace{5mm}
%\begin{tikzpicture}
%	\draw[xstep=1cm,ystep=5mm,color=gray] (-0.01,0) grid (4,.5);
%	\draw[xstep=1cm,ystep=5mm,color=gray] (5,0) grid (10,.5);
%	\node[anchor=west] at (-0.1,1.00) {stack};
%	\node[anchor=west] at (8.9,1.00) {buffer};
%	\foreach \i in {0.5,8.5,9.5} {
%		\node[fill=gray, circle] at (\i,0.25) {};
%	}
%	\foreach \i in {1.5,2.5,3.5,5.5,6.5,7.5} {
%		\node[fill=black, circle] at (\i,0.25) {};
%	}
%\end{tikzpicture}
%}
%\centering
%\onslide<6>{
%\fbox{
%\begin{minipage}{.5\textwidth}
%\begin{tikzpicture}[every node/.append style={font=\rmfamily}]
%	\node[anchor=west,style={font=\sffamily}] at (-1.2,0.25){stack};
%	\draw[xstep=1cm,ystep=5mm,color=gray] (-0.01,0) grid (4,.5);
%	\node[fill=black, circle] at (0.5,0.25) {};
%	\node[fill=blue, circle] at (2.5,0.25) {};
%	\node[anchor=west] at (1,0.25) {\small You};
%	\node[anchor=west] at (3,0.25) {\small take};
%\end{tikzpicture}
%
%\vspace{1cm}
%\begin{tikzpicture}[every node/.append style={font=\rmfamily}]
%	\node[anchor=west,style={font=\sffamily}] at (3.8,0.25){buffer};
%	\draw[xstep=1cm,ystep=5mm,color=gray] (5,0) grid (9,.5);
%	\node[fill=red, circle] at (5.5,0.25) {};
%	\node[anchor=west] at (6,0.25) {\small a};
%	\node[anchor=west] at (7,0.25) {\small long};
%	\node[anchor=west] at (8,0.25) {\small bath};
%\end{tikzpicture}
%\end{minipage}
%\begin{minipage}{.4\textwidth}
%\scalebox{.8}{
%\begin{tikzpicture}[level distance=1cm, sibling distance=1cm, ->,
%    every node/.append style={font=\rmfamily}]
%    \node[anchor=west,style={font=\sffamily}] at (5,0) {graph};
%    \draw[color=gray] (1.2,.3) rectangle (4.9,-3.2);
%    \node(ROOT)[fill=black, circle, visible on=<2->] at (3,0) {}
%      child {node (You) {You} edge from parent node [left] {\scriptsize $A$}}
%      child {node {want} edge from parent node [left] {\scriptsize $P$}}
%      child {node (totakealongbath) [fill=blue, circle] {}
%      {
%        child {node {to} edge from parent node [left] {\scriptsize $F$}}
%        child {node (takeabath) [fill=red, circle] {}
%        {
%          child {node {take} edge from parent node [right] {\scriptsize $C$}}
%          child [opacity=0] {node {a} edge from parent node [right] {\scriptsize $F$}}
%          child [opacity=0] {node (long) {long} edge from parent [draw=none]}
%          child [opacity=0] {node {bath} edge from parent node [right] {\scriptsize $C$}}
%        } edge from parent [draw=none]}
%      } edge from parent [draw=none]}
%      ;
%\end{tikzpicture}
%}
%\end{minipage}
%}
%}
%\onslide<2->{
%\scalebox{.7}{
%\begin{tikzpicture}[->]
%	\tiny
%	\tikzstyle{main}=[circle, minimum size=7mm, draw=black!80, node distance=12mm]
%	\foreach \i/\word in {1/{You},3/{want},5/{to},7/{take},9/{a},11/{long},13/{bath}} {
%	    \onslide<2->\node (x\i) at (\i,-1.3) {\Large\textrm\word};
%	    \onslide<2->\node[main, fill=white!100] (h\i) at (\i,0) {LSTM};
%        \onslide<2->\path (x\i) edge (h\i);
%	    \onslide<3->\node[main, fill=white!100] (i\i) at (\i.5,.8) {LSTM};
%        \onslide<3->\path (x\i) edge [bend right] (i\i);
%	    \onslide<4->\node[main, fill=white!100] (l\i) at (\i.5,2.3) {LSTM};
%        \onslide<4->\path (h\i) edge [bend left] (l\i);
%        \onslide<4->\path (i\i) edge (l\i);
%	    \onslide<5->\node[main, fill=white!100] (k\i) at (\i,3.1) {LSTM};
%        \onslide<5->\path (i\i) edge [bend left] (k\i);
%        \onslide<5->\path (h\i) edge [bend left] (k\i);
%	}
%	\foreach \current/\next in {1/3,3/5,5/7,7/9,9/11,11/13} {
%        \onslide<2->\path (h\current) edge (h\next);
%        \onslide<3->\path (i\next) edge (i\current);
%        \onslide<4->\path (l\current) edge (l\next);
%        \onslide<5->\path (k\next) edge (k\current);
%	}
%    \onslide<6>\node[main, fill=white!100] (mlp) at (7,4.6) {MLP};
%	\onslide<6>\foreach \i in {5,7,9} {
%        \path (l\i) edge (mlp);
%        \path (k\i) edge (mlp);
%    }
%    \coordinate (state) at (10.5,6.5);
%    \onslide<6>\path (state) edge [bend left] (mlp);
%    \onslide<6>\node (transition) at (7,5.8) {\large\textsc{Node}$_C$};
%    \onslide<6>\path (mlp) edge (transition);
%\end{tikzpicture}
%}
%}
%\end{frame}
%
%
%\section{Experiments}
%
%\begin{frame}
%\frametitle{Experimental Setup}
%\begin{itemize}
% \item UCCA Wikipedia corpus ($\stackrel{\text{train}}{4268}+\stackrel{\text{dev}}{454}+\stackrel{\text{test}}{503}$ sentences).
% \item Out-of-domain: English part of English-French parallel corpus,
% 	\textit{Twenty Thousand Leagues Under the Sea} (506 sentences).
%\end{itemize}
%
%\vfill
%\begin{center}
%  \includegraphics[width=.5\linewidth]{wikipedia.png}
%  \includegraphics[width=.5\linewidth]{squid.jpg}
%\end{center}
%\end{frame}
%
%\begin{frame}
%\frametitle{Baselines}
%No existing UCCA parsers $\Rightarrow$ conversion-based approximation.
%
%\vfill
%\footnotesize
%Bilexical DAG parsers (allow {\color{orange}reentrancy}):
%\begin{itemize}
% \item DAGParser \cite{ribeyre-villemontedelaclergerie-seddah:2014:SemEval}:
% transition-based.
% \item TurboParser \cite{almeida-martins:2015:SemEval}:
% graph-based.
%\end{itemize}
%
%Tree parsers (all transition-based):
%\begin{itemize}
% \item MaltParser \cite{nivre2007maltparser}: bilexical tree parser.
% \item Stack LSTM Parser \cite{dyer2015transition}: bilexical tree parser.
% \item \textsc{uparse} \cite{maier2015discontinuous}: allows {\color{blue}non-terminals}, {\color{red}discontinuity}.
%\end{itemize}
%
%\vfill
%\begin{center}
%	\begin{dependency}
%	\begin{deptext}[column sep=1.5em,ampersand replacement=\^,font=\rmfamily]
%	You \^ want \^ to \^ take \^ a \^ long \^ bath \\
%	\end{deptext}
%	\depedge{2}{1}{$A$}
%	\depedge{2}{4}{$A$}
%	\depedge[dashed,edge start x offset=6pt]{4}{1}{$A$}
%	\depedge{4}{3}{$F$}
%	\depedge{4}{5}{$F$}
%	\depedge{4}{6}{$D$}
%	\depedge{4}{7}{$C$}
%	\end{dependency}
%	\captionof{figure}{UCCA bilexical DAG approximation (for tree, delete remote edges).}
%\end{center}
%\end{frame}
%
%
%\begin{frame}
%\frametitle{Bilexical Graph Approximation}
%\begin{enumerate}
% \item Convert UCCA to bilexical dependencies.
% \item Train bilexical parsers and apply to test sentences.
% \item Reconstruct UCCA graphs and compare with gold standard.
%\end{enumerate}
%\vfill
%
%\begin{flushright}
%	\begin{tikzpicture}[level distance=13mm, sibling distance=17mm, ->,
%	    every circle node/.append style={fill=black}]
%	  \tikzstyle{word} = [font=\rmfamily,color=black]
%	  \node (ROOT) [circle] {}
%	    child {node (After) [word] {After} edge from parent node[left] {\scriptsize $L$}}
%	    child {node (graduation) [circle] {}
%	    {
%	      child {node [word] {graduation} edge from parent node[left] {\scriptsize $P$}}
%	    } edge from parent node[left] {\scriptsize $H$} }
%	    child {node [word] {,} edge from parent node[right] {\scriptsize $U$}}
%	    child {node (moved) [circle] {}
%	    {
%	      child {node (Joe) [word] {Joe} edge from parent node[left] {\scriptsize $A$}}
%	      child {node [word] {moved} edge from parent node[left] {\scriptsize $P$}}
%	      child {node [circle] {}
%	      {
%	        child {node [word] {to} edge from parent node[left] {\scriptsize $R$}}
%	        child {node [word] {Paris} edge from parent node[right] {\scriptsize $C$}}
%	      } edge from parent node[right] {\scriptsize $A$} }
%	    } edge from parent node[right] {\scriptsize $H$} }
%	    ;
%	  \draw[dashed,->] (graduation) to node [auto] {\scriptsize $A$} (Joe);
%	\end{tikzpicture}
%\end{flushright}
%
%\vspace{-14mm}
%\begin{flushleft}
%	\begin{dependency}
%	\begin{deptext}[column sep=.7em,ampersand replacement=\^,font=\rmfamily]
%	After \^ graduation \^ , \^ Joe \^ moved \^ to \^ Paris \\
%	\end{deptext}
%	\depedge{2}{1}{$L$}
%	\depedge{2}{3}{$U$}
%	\depedge[dashed]{2}{4}{$A$}
%	\depedge{5}{4}{$A$}
%	\depedge{2}{5}{$H$}
%	\depedge{7}{6}{$R$}
%	\depedge{5}{7}{$A$}
%	\end{dependency}
%\end{flushleft}
%\end{frame}
%
%\begin{frame}
%\frametitle{Evaluation}
%Comparing graphs over the same sequence of tokens,
%\begin{itemize}
%\item Match edges by their terminal yield and label.
%\item Calculate \textbf{labeled precision, recall and F1} scores.
%\item Separate primary and remote edges.
%\end{itemize}
%\vfill
%\begin{adjustbox}{frame,scale=.75,center}
%	\begin{tikzpicture}[level distance=15mm, sibling distance=15mm, ->,
%	    every circle node/.append style={fill=black}]
%	  \tikzstyle{word} = [font=\rmfamily,color=black]
%	  \node at (-1,.7) {gold};
%	  \node (ROOT) at (0,0) [circle] {}
%	    child {node (After) [word] {After} edge from parent node[left] {$L$}}
%	    child {node (graduation) [circle] {}
%	    {
%	      child {node [word] {graduation} edge from parent node[left] {$P$}}
%	    } edge from parent node[left] {$H$} }
%	    child {node [word] {,} edge from parent node[right] {$U$}}
%	    child {node (moved) [circle] {}
%	    {
%	      child {node (Joe) [word] {Joe} edge from parent node[left] {$A$}}
%	      child {node [word] {moved} edge from parent node[left] {$P$}}
%	      child {node [circle] {}
%	      {
%	        child {node [word] {to} edge from parent node[left] {$R$}}
%	        child {node [word] {Paris} edge from parent node[right] {$C$}}
%	      } edge from parent node[right] {$A$} }
%	    } edge from parent node[right] {$H$} }
%	    ;
%	  \draw[dashed,->] (graduation) to node [auto] {$A$} (Joe);
%	  \node at (6,.7) {predicted};
%	  \node (ROOT_) at (7,0) [circle] {}
%	    child {node (After_) [word] {After} edge from parent node[left] {$L$}}
%	    child {node (graduation_) [circle] {}
%	    {
%	      child[red] {node [word] {graduation} edge from parent node[left] {$S$}}
%	    } edge from parent node[left] {$H$} }
%	    child {node [word] {,} edge from parent node[right] {$U$}}
%	    child {node (moved) [circle,xshift=3mm,yshift=-7mm] {}
%	    {
%	      child {node (Joe_) [word] {Joe} edge from parent node[left] {$A$}}
%	      child {node [word] {moved} edge from parent node[left] {$P$}}
%	      child[red] {node [word] {to} edge from parent node[left] {$F$}}
%	      child[red] {node (Paris_) [word] {Paris} edge from parent node[right] {$A$}}
%	    } edge from parent node[right] {$H$} }
%	    ;
%	  \draw[bend left,dashed,->] (graduation_) to node [auto] {$A$} (Joe_);
%	  \draw[bend left,dashed,->,red] (graduation_) to node [auto] {$A$} (Paris_);
%	\end{tikzpicture}
%\end{adjustbox}
%\vfill
%\begin{adjustbox}{scale=.75,center}
%	Primary:
%	\begin{tabular}{ccc}
%		\textbf{LP} & \textbf{LR} & \textbf{LF} \\ \hline
%		$\frac69=67\%$ & $\frac6{10}=60\%$ & 64\%
%	\end{tabular}
%	\hspace{1cm}
%	Remote:
%	\begin{tabular}{ccc}
%		\textbf{LP} & \textbf{LR} & \textbf{LF} \\ \hline
%		$\frac12=50\%$ & $\frac11=100\%$ & 67\%
%	\end{tabular}
%\end{adjustbox}
%\end{frame}
%
%\begin{frame}
%\frametitle{Results}
%TUPA-\textsc{BiLSTM} obtains the highest F-scores in all metrics:
%\begin{center}
%	\begin{tabular}{l|ccc|ccc}
%		& \multicolumn{3}{c|}{Primary edges} & \multicolumn{3}{c}{Remote edges} \\
%		& \textbf{LP} & \textbf{LR} & \textbf{LF} & \textbf{LP} & \textbf{LR} & \textbf{LF} \\
%		\hline
%		TUPA-\textsc{Sparse}
%		& 64.5 & 63.7 & 64.1 & 19.8 & 13.4 & 16 \\
%		TUPA-\textsc{MLP}
%		& 65.2 & 64.6 & 64.9 & 23.7 & 13.2 & 16.9 \\
%		TUPA-\textsc{BiLSTM}
%		& 74.4 & 72.7 & \textbf{73.5} & 47.4 & 51.6 & \textbf{49.4} \\
%		\hline
%		\scriptsize Bilexical DAG
%		& & & \scriptsize (91) & & & \scriptsize (58.3) \\
%		DAGParser
%		& 61.8 & 55.8 & 58.6 & 9.5 & 0.5 & 1 \\
%		TurboParser
%		& 57.7 & 46 & 51.2 & 77.8 & 1.8 & 3.7 \\
%		\hline
%		\scriptsize Bilexical tree
%		& & & \scriptsize (91) & & & \scriptsize -- \\
%		MaltParser
%		& 62.8 & 57.7 & 60.2 & -- & -- & -- \\
%		Stack LSTM
%		& 73.2 & 66.9 & 69.9 & -- & -- & -- \\
%		\hline
%		\scriptsize Tree
%		& & & \scriptsize (100) & & & \scriptsize -- \\
%		\textsc{uparse}
%		& 60.9 & 61.2 & 61.1 & -- & -- & --
%	\end{tabular}
%	\captionof{table}{Results on the Wiki test set.}
%\end{center}
%\end{frame}
%
%\begin{frame}
%\frametitle{Results}
%Comparable on out-of-domain test set:
%\begin{center}
%	\begin{tabular}{l|ccc|ccc}
%		& \multicolumn{3}{c|}{Primary edges} & \multicolumn{3}{c}{Remote edges} \\
%		& \textbf{LP} & \textbf{LR} & \textbf{LF} & \textbf{LP} & \textbf{LR} & \textbf{LF} \\
%		\hline
%		TUPA-\textsc{Sparse}
%		& 59.6 & 59.9 & 59.8 & 22.2 & 7.7 & 11.5 \\
%		TUPA-\textsc{MLP}
%		& 62.3 & 62.6 & 62.5 & 20.9 & 6.3 & 9.7 \\
%		TUPA-\textsc{BiLSTM}
%		& 68.7 & 68.5 & \textbf{68.6} & 38.6 & 18.8 & \textbf{25.3} \\
%		\hline
%		\scriptsize Bilexical DAG
%		& & & \scriptsize (91.3) & & & \scriptsize (43.4) \\
%		DAGParser
%		& 56.4 & 50.6 & 53.4 & -- & 0 & 0 \\
%		TurboParser
%		& 50.3 & 37.7 & 43.1 & 100 & 0.4 & 0.8 \\
%		\hline
%		\scriptsize Bilexical tree
%		& & & \scriptsize (91.3) & & & \scriptsize -- \\
%		MaltParser
%		& 57.8 & 53 & 55.3 & -- & -- & -- \\
%		Stack LSTM
%		& 66.1 & 61.1 & 63.5 & -- & -- & -- \\
%		\hline
%		\scriptsize Tree
%		& & & \scriptsize (100) & & & \scriptsize -- \\
%		\textsc{uparse}
%		& 52.7 & 52.8 & 52.8 & -- & -- & --
%	\end{tabular}
%	\captionof{table}{Results on the 20K Leagues out-of-domain set.}
%\end{center}
%\end{frame}
%
%
%
%\begin{frame}
%\frametitle{Conclusion}
%\begin{itemize}
% \item UCCA's semantic distinctions require a graph structure including {\color{blue}non-terminals}, {\color{orange}reentrancy} and {\color{red}discontinuity}.
% \item TUPA is an accurate transition-based UCCA parser,
% 	and the \textbf{first} to support UCCA and any DAG over the text tokens.
% \item Outperforms strong conversion-based baselines.
%\end{itemize}
%
%\onslide<2->{
%Future Work:
%
%\begin{itemize}
% \item More languages (German corpus construction is underway).
% \item Parsing other schemes, such as AMR.
% \item Compare semantic representations through conversion.
% \item Text simplification, MT evaluation and other applications.
%\end{itemize}
%}
%
%\vfill
%Code: \url{github.com/danielhers/tupa}
%
%Demo: \url{bit.ly/tupademo}
%
%Corpora: \url{cs.huji.ac.il/~oabend/ucca.html}
%
%\onslide<3>{
%\vfill
%\begin{flushright}
%	Thank you!
%\end{flushright}
%}
%\end{frame}
%
%
%\section{Backup}
%
%
%\begin{frame}
%\frametitle{UCCA Corpora}
%\centering
%\begin{tabular}{l|ccc|c}
%	& \multicolumn{3}{c|}{Wiki} & 20K \\
%	& \small Train & \small Dev & \small Test & Leagues \\
%	\hline
%	\# passages & 300 & 34 & 33 & 154 \\
%	\# sentences & 4268 & 454 & 503 & 506 \\
%	\hline
%	\# nodes & 298,993 & 33,704 & 35,718 & 29,315 \\
%	\% terminal & 42.96 & 43.54 & 42.87 & 42.09 \\
%	\% non-term. & 58.33 & 57.60 & 58.35 & 60.01 \\
%	\% \textbf{discont.} & \textbf{0.54} & \textbf{0.53} & \textbf{0.44} & \textbf{0.81} \\
%	\% \textbf{reentrant} & \textbf{2.38} & \textbf{1.88} & \textbf{2.15} & \textbf{2.03} \\
%	\hline
%	\# edges & 287,914 & 32,460 & 34,336 & 27,749 \\
%	\% primary & 98.25 & 98.75 & 98.74 & 97.73 \\
%	\% remote & 1.75 & 1.25 & 1.26 & 2.27 \\
%	\hline
%	\multicolumn{3}{l}{\footnotesize Average per non-terminal node} \\
%	\# children & 1.67 & 1.68 & 1.66 & 1.61 
%\end{tabular}
%\captionof{table}{Corpus statistics.}
%\end{frame}
%
%\begin{frame}
%\frametitle{Evaluation}
%\textit{Mutual edges} between predicted graph $G_p=(V_p,E_p,\ell_p)$
%and gold graph $G_g=(V_g,E_g,\ell_g)$,
%both over terminals $W = \{w_1,\ldots,w_n\}$:
%\[
%M(G_p,G_g) =
%    \Bigl\{(e_1,e_2) \in E_p \times E_g \;\Big|\;
%    y(e_1) = y(e_2) \wedge \ell_p(e_1)=\ell_g(e_2)\Bigr\}
%\]
%The yield $y(e) \subseteq W$ of an edge $e=(u,v)$ in either graph
%is the set of terminals in $W$ that are descendants of $v$. \hfill
%$\ell$ is the edge label.
%
%\vfill
%Labeled precision, recall and F-score are then defined as:
%\[
%\text{LP} = \frac{|M(G_p,G_g)|}{|E_p|},\quad
%\text{LR} = \frac{|M(G_p,G_g)|}{|E_g|},
%\]
%\[
%\text{LF} = \frac{2 \cdot \text{LP} \cdot \text{LR}}{\text{LP} + \text{LR}}.
%\]
%Two variants:
%one for primary edges, and another for remote edges.
%\end{frame}

\end{document}
